{% extends "base.html" %}
{% load partials %}
{% block content %}
{% partialdef config_page inline %}
<div id="config_content" class="flex flex-col items-center w-full h-fit gap-8">
    <h1 class="text-2xl font-semibold">{{ entrance.name }}</h1>
    <div class="flex flex-col lg:flex-row gap-4 w-full h-full justify-between">
        <div class="w-full">
            {% component "card" %}
            {% fill "content" %}
            <div class="p-4">
                <h2 class="text-xl font-semibold">Navn</h2>
                <p>{{ entrance.name }}</p>
                {% if device %}
                <form method="post">
                    {% csrf_token %}
                    <h2 class="text-xl font-semibold">Request Image</h2>
                    <input name="request_image" type="hidden" value="true">
                    <button class="px-6 py-3 font-bold text-center text-white uppercase transition-all rounded-lg active:opacity-85 hover:scale-[102%] shadow-md bg-gradient-to-r from-aau to-aau-light disabled:from-gray-400 disabled:to-gray-400" {% if not allow_image_request %} disabled {% endif %}>Request</button>
                </form>
                <h2 class="text-xl font-semibold">Device installed <i class="bi-check"></i></h2>
                <h2 class="text-xl font-semibold">API Key</h2>
                <div>
                    {% if api_key %}
                    <input
                        value="{{ api_key }}"
                        class="rounded-lg border border-solid border-gray-300 py-2 px-3 transition-all focus:border-aau-light disabled:text-gray-600 disabled:bg-gray-100 disabled:cursor-not-allowed"
                        {% if not api_key_available %}
                        disabled
                        {% endif %}
                        oninput="this.value = '{{ api_key }}'"
                    >
                    <button
                        hx-delete="{% url 'api_key' entrance.device.id %}"
                        hx-confirm="Are you sure you want to remove the API key for {{ entrance.name }}?"
                        hx-target="#config_content"
                    >
                        <i class="bi-trash"></i>
                    </button>
                    {% else %}
                    <button
                        hx-post="{% url 'api_key' entrance.device.id %}"
                        hx-target="#config_content"
                    >
                        <i class="bi-plus"></i>
                    </button>
                    {% endif %}
                </div>
                {% else %}
                <h2 class="text-xl font-semibold">No device installed <i class="bi-x"></i></h2>
                {% endif %}
            </div>
            <div>
                {% component "latest_events" entrances=[entrance] items=3 %}{% endcomponent %}
            </div>
            {% endfill %}
            {% endcomponent %}
        </div>
        {% if perms.accounts.change_user %}
        <div class="w-full flex-col gap-4 h-fit">
            {% component "card" %}
            {% fill "content" %}
            <div class="relative w-full h-full p-4 items-center">
                <img id="backgroundImage" src="{{ image.url }}">
                <canvas id="drawingCanvas" class="absolute top-4 left-4"></canvas>
            </div>
            {% endfill %}
            {% endcomponent %}
            {% component "card" %}
            {% fill "content" %}
            <div class="p-4">
                <label for="boxes">Ændr koordinater for:</label>
                <select id="boxes" name="boxes">
                  <option value="entry_box">Indgang</option>
                  <option value="exit_box">Udgang</option>
                </select> 

                <h2 class="text-xl font-semibold">Øverste venstre hjørne</h2>
                <div class="flex flex-col gap-4 justify-between lg:flex-row">
                    <div class="flex flex-col w-full">
                        <h3 class="text-m">X-koordinat (px)</h3>
                        <input
                            id="x_top"
                            name="top-left-x"
                            type="number"
                            class="w-full rounded-lg border border-solid border-gray-300 py-2 px-3 transition-all focus:border-aau-light focus:bg-white"
                            placeholder="e.g. 583"
                        >
                    </div>
                    <div class="flex flex-col w-full">
                        <h3 class="text-m">Y-koordinat (px)</h3>
                        <input
                            id="y_top"
                            name="top-left-y"
                            type="number"
                            class="w-full rounded-lg border border-solid border-gray-300 py-2 px-3 transition-all focus:border-aau-light focus:bg-white"
                            placeholder="e.g. 363"
                        >
                    </div>
                </div>
                <h2 class="text-xl font-semibold">Nedre højre hjørne</h2>
                <div class="flex flex-col gap-4 justify-between lg:flex-row">
                    <div class="flex flex-col w-full">
                        <h3 class="text-m">X-koordinat (px)</h3>
                        <input
                            id="x_btm"
                            name="bottom-right-x"
                            type="number"
                            class="w-full rounded-lg border border-solid border-gray-300 py-2 px-3 transition-all focus:border-aau-light focus:bg-white"
                            placeholder="e.g. 281"
                        >
                    </div>
                    <div class="flex flex-col w-full">
                        <h3 class="text-m">Y-koordinat (px)</h3>
                        <input
                            id="y_btm"
                            name="bottom-right-y"
                            type="number"
                            class="w-full rounded-lg border border-solid border-gray-300 py-2 px-3 transition-all focus:border-aau-light focus:bg-white"
                            placeholder="e.g. 927"
                        >
                    </div>
                </div>
                <button
                    id="drawBtn"
                    class="w-full px-6 py-3 mt-6 mb-2 font-bold text-center text-white uppercase transition-all rounded-lg active:opacity-85 hover:scale-[102%] shadow-md bg-gradient-to-r from-aau to-aau-light"
                >
                    Send kasse
                </button>
            </div>  
            {% endfill %}
            {% endcomponent %}
        </div>
        {% endif %}
    </div>
</div>
{% endpartialdef config_page %}
{% endblock %}
{% block js %}
<script>
document.addEventListener("DOMContentLoaded", function () {
    const canvas = document.getElementById("drawingCanvas");
    if (!canvas) return; // Ensures the script runs only when the canvas exists

    const img = document.getElementById("backgroundImage");

    let boxes = {
        entry_box: { x_top: 50, y_top: 50, x_btm: 100, y_btm: 100 },
        exit_box: { x_top: 150, y_top: 50, x_btm: 200, y_btm: 100 }
    };

    let dragBoxBeginCoord = {x_top: 0, y_top: 0, x_btm: 0, y_btm: 0}
    let dragMouseBeginCoord = [0,0]

    let selectedBox = "entry_box";
    
    let selectedCorner = "null";
    let closestCorner = "null";
    let isDraggingBox= false;

    const minBoxSize = 50

    const cornerSelectDistance = 20;

    const originalWidth = img.naturalWidth;
    const originalHeight = img.naturalHeight;

    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
        canvas.width = img.clientWidth;
        canvas.height = img.clientHeight;
        drawRectangles();
    }

    window.addEventListener("load", resizeCanvas);
    window.addEventListener("resize", resizeCanvas);

    function remapWidth(value) {
        return canvas.width * value / originalWidth;
    }

    function remapHeight(value) {
        return canvas.height * value / originalHeight;
    }

    function remapWidthToOriginal(value) {
        return originalWidth * value / canvas.width;
    }

    function remapHeightToOriginal(value) {
        return originalHeight * value / canvas.height;
    }


    function drawRectangles() {
        const success_box_color = "rgba(0,255,0,0.5)";
        const fail_box_color = "rgba(255,0,0,0.5)";

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        Object.keys(boxes).forEach((boxKey) => {
            const values = boxes[boxKey];
            const { x_top, y_top, x_btm, y_btm } = values;

            // Ensure x_top is not greater than x_btm, and y_top is not greater than y_btm
            if (x_top > x_btm || y_top > y_btm) {
                ctx.fillStyle = fail_box_color;
            } else {
                ctx.fillStyle = "rgba(255,0,0,0.5)";
            }

            // Calculate rectangle size
            const size_x = x_btm - x_top;
            const size_y = y_btm - y_top;

            // Draw the rectangle
            ctx.fillRect(remapWidth(x_top), remapHeight(y_top), remapWidth(size_x), remapHeight(size_y));
            
            if (boxKey == selectedBox) {
                ctx.fillStyle = "rgba(120,120,120)";
                ctx.lineWidth = 1; // Thickness of the rim
                ctx.strokeStyle = "rgba(60,60,60)"; // Rim color

                ctx.beginPath();
                ctx.arc(remapWidth(x_top), remapHeight(y_top), remapWidth(cornerSelectDistance), 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke(); 

                ctx.beginPath();
                ctx.arc(remapWidth(x_btm), remapHeight(y_top), remapWidth(cornerSelectDistance), 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke(); 

                ctx.beginPath();
                ctx.arc(remapWidth(x_top,), remapHeight(y_btm), remapWidth(cornerSelectDistance), 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke(); 

                ctx.beginPath();
                ctx.arc(remapWidth(x_btm), remapHeight(y_btm), remapWidth(cornerSelectDistance), 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke(); 

                ctx.fillStyle = "rgba(160,160,160,1)";
                if (closestCorner != "null") {
                    switch (closestCorner) {
                        case "top-left":
                            ctx.beginPath();
                            ctx.arc(remapWidth(x_top), remapHeight(y_top), remapWidth(cornerSelectDistance+5), 0, Math.PI * 2);
                            ctx.fill();
                            break;
                        case "top-right":
                            ctx.beginPath();
                            ctx.arc(remapWidth(x_btm), remapHeight(y_top), remapWidth(cornerSelectDistance+5), 0, Math.PI * 2);
                            ctx.fill();
                            break;
                        case "bottom-left":
                            ctx.beginPath();
                            ctx.arc(remapWidth(x_top), remapHeight(y_btm), remapWidth(cornerSelectDistance+5), 0, Math.PI * 2);
                            ctx.fill();
                            break;
                        case "bottom-right":
                            ctx.beginPath();
                            ctx.arc(remapWidth(x_btm), remapHeight(y_btm), remapWidth(cornerSelectDistance+5), 0, Math.PI * 2);
                            ctx.fill();
                            break;
                    }
                    ctx.lineWidth = 1; // Thickness of the rim
                    ctx.strokeStyle = "black"; // Rim color
                    ctx.stroke(); // Draw the rim
                }
            }

        });


    }

    document.getElementById("boxes").addEventListener("change", function(event) {
        selectedBox = event.target.value;
        updateFormFields();
        drawRectangles();
    });

    function updateFormFields() {
        const values = boxes[selectedBox];
        document.getElementById("x_top").value = values.x_top;
        document.getElementById("y_top").value = values.y_top;
        document.getElementById("x_btm").value = values.x_btm;
        document.getElementById("y_btm").value = values.y_btm;
    }

    function calculateDistance(x1, y1, x2, y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    function EndBoxManipulation() {
        // Snaps to edge
        let snapDistance = 20;
        let box = boxes[selectedBox];
        const { x_top, y_top, x_btm, y_btm } = box;

        // Snap to edge on corresponding side
        if (x_top < snapDistance) {
            box.x_top = 0;
        }
        if (y_top < snapDistance) {
            box.y_top = 0;
        }
        if (x_btm > originalWidth - snapDistance) {
            box.x_btm = originalWidth;
        }
        if (y_btm > originalHeight - snapDistance) {
            box.y_btm = originalHeight;
        }

        // Stop box from squishing to the sides
        if (x_top > originalWidth - minBoxSize) {
            box.x_top = originalWidth - minBoxSize;
        }
        if (y_top > originalHeight - minBoxSize) {
            box.y_top = originalHeight - minBoxSize;
        }
        if (x_btm < minBoxSize) {
            box.x_btm = minBoxSize;
        }
        if (y_btm > minBoxSize) {
            box.y_btm = minBoxSize;
        }
    }

    canvas.addEventListener("pointermove", function(event) {
        const rect = canvas.getBoundingClientRect();
        const x = remapWidthToOriginal(event.clientX - rect.left);
        const y = remapHeightToOriginal(event.clientY - rect.top);

        let box = boxes[selectedBox];
        const { x_top, y_top, x_btm, y_btm } = box;

        if (selectedCorner == "null") {
            const distances = {
                "top-left": calculateDistance(x, y, x_top, y_top),
                "top-right": calculateDistance(x, y, x_btm, y_top),
                "bottom-left": calculateDistance(x, y, x_top, y_btm),
                "bottom-right": calculateDistance(x, y, x_btm, y_btm)
            };

            closestCorner = Object.keys(distances).reduce((minCorner, currentCorner) => {
                return distances[currentCorner] < distances[minCorner] ? currentCorner : minCorner;
            });
            

            if (distances[closestCorner] > cornerSelectDistance) {
                closestCorner = "null"
            }
        } 
        
        switch (selectedCorner) {
            case "top-left":
                if (x > box.x_btm - minDragDistanceBetweenCorners) {
                    box.x_top = Math.max(box.x_btm-minDragDistanceBetweenCorners,0);
                } else {
                    box.x_top = x;
                }
                if (y > box.y_btm - minDragDistanceBetweenCorners) {
                    box.y_top = Math.max(y_btm-minDragDistanceBetweenCorners,0);
                } else {
                    box.y_top = y;
                }
                break;
            case "top-right":
                if (x < box.x_top + minDragDistanceBetweenCorners) {
                    box.x_btm = Math.min(x_top+minDragDistanceBetweenCorners,originalWidth);
                } else {
                    box.x_btm = x;
                }
                if (y > box.y_btm - minDragDistanceBetweenCorners) {
                    box.y_top = Math.max(y_btm-minDragDistanceBetweenCorners,0);
                } else {
                    box.y_top = y;
                }
                break;
            case "bottom-left":
                if (x > box.x_btm - minDragDistanceBetweenCorners) {
                    box.x_top = Math.max(x_btm-minDragDistanceBetweenCorners,0);
                } else {
                    box.x_top = x;
                }
                if (y < box.y_top + minDragDistanceBetweenCorners) {
                    box.y_btm = Math.min(y_top+minDragDistanceBetweenCorners,originalHeight);
                } else {
                    box.y_btm = y;
                }
                break;
            case "bottom-right":
                if (x < box.x_top + minDragDistanceBetweenCorners) {
                    box.x_btm = Math.min(x_top+minDragDistanceBetweenCorners,originalWidth);
                } else {
                    box.x_btm = x;
                }
                if (y < box.y_top + minDragDistanceBetweenCorners) {
                    box.y_btm = Math.min(y_top+minDragDistanceBetweenCorners,originalHeight);
                } else {
                    box.y_btm = y;
                }
                break;
        }

        if (isDraggingBox == true) {
            box.x_top = dragBoxBeginCoord.x_top + (x - dragMouseBeginCoord[0]);
            box.x_btm = dragBoxBeginCoord.x_btm + (x - dragMouseBeginCoord[0]);
            box.y_top = dragBoxBeginCoord.y_top + (y - dragMouseBeginCoord[1]);
            box.y_btm = dragBoxBeginCoord.y_btm + (y - dragMouseBeginCoord[1]);
        }

        updateFormFields()
        drawRectangles();
    });

    canvas.addEventListener("pointerdown", function(event) {
        selectedCorner = closestCorner;
        boxDrag = "null";

        // box drag
        if (selectedCorner == "null") {
            const rect = canvas.getBoundingClientRect();
            const x = remapWidthToOriginal(event.clientX - rect.left);
            const y = remapHeightToOriginal(event.clientY - rect.top);
            if(x_btm > x > x_top && y_btm > y > t_top){
                boxDrag = "true";
                originalBoxCoord = boxes[selectedBox];
                dragBeginCoord = [x,y]
            }
        }
    });

    canvas.addEventListener("pointerup", function(event) {
        EndBoxManipulation();
        selectedCorner = "null"
        boxDrag = "null";

        updateFormFields();
        drawRectangles();
    });

    canvas.addEventListener("pointerleave", function(event) {
        EndBoxManipulation();
        selectedCorner = "null";
        closestCorner = "null";
        boxDrag = "null";

        updateFormFields();
        drawRectangles();
    });

    updateFormFields();
    drawRectangles();
});
</script>
{% endblock %}
